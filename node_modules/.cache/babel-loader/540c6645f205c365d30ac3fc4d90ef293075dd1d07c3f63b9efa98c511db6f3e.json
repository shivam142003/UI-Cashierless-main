{"ast":null,"code":"import { createTransferCheckedInstruction, getAccount, getAssociatedTokenAddress, getMint } from '@solana/spl-token';\nimport { LAMPORTS_PER_SOL, SystemProgram, Transaction, TransactionInstruction } from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID, SOL_DECIMALS, TEN } from './constants.js';\n/**\n * Thrown when a Solana Pay transfer transaction can't be created from the fields provided.\n */\nexport class CreateTransferError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'CreateTransferError';\n  }\n}\n/**\n * Create a Solana Pay transfer transaction.\n *\n * @param connection - A connection to the cluster.\n * @param sender - Account that will send the transfer.\n * @param fields - Fields of a Solana Pay transfer request URL.\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {CreateTransferError}\n */\nexport async function createTransfer(connection, sender, _ref) {\n  let {\n    recipient,\n    amount,\n    splToken,\n    reference,\n    memo\n  } = _ref;\n  let {\n    commitment\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // Check that the sender and recipient accounts exist\n  const senderInfo = await connection.getAccountInfo(sender);\n  if (!senderInfo) throw new CreateTransferError('sender not found');\n  const recipientInfo = await connection.getAccountInfo(recipient);\n  if (!recipientInfo) throw new CreateTransferError('recipient not found');\n  // A native SOL or SPL token transfer instruction\n  const instruction = splToken ? await createSPLTokenInstruction(recipient, amount, splToken, sender, connection) : await createSystemInstruction(recipient, amount, sender, connection);\n  // If reference accounts are provided, add them to the transfer instruction\n  if (reference) {\n    if (!Array.isArray(reference)) {\n      reference = [reference];\n    }\n    for (const pubkey of reference) {\n      instruction.keys.push({\n        pubkey,\n        isWritable: false,\n        isSigner: false\n      });\n    }\n  }\n  // Create the transaction\n  const transaction = new Transaction();\n  transaction.feePayer = sender;\n  transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n  // If a memo is provided, add it to the transaction before adding the transfer instruction\n  if (memo != null) {\n    transaction.add(new TransactionInstruction({\n      programId: MEMO_PROGRAM_ID,\n      keys: [],\n      data: Buffer.from(memo, 'utf8')\n    }));\n  }\n  // Add the transfer instruction to the transaction\n  transaction.add(instruction);\n  return transaction;\n}\nasync function createSystemInstruction(recipient, amount, sender, connection) {\n  // Check that the sender and recipient accounts exist\n  const senderInfo = await connection.getAccountInfo(sender);\n  if (!senderInfo) throw new CreateTransferError('sender not found');\n  const recipientInfo = await connection.getAccountInfo(recipient);\n  if (!recipientInfo) throw new CreateTransferError('recipient not found');\n  // Check that the sender and recipient are valid native accounts\n  if (!senderInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('sender owner invalid');\n  if (senderInfo.executable) throw new CreateTransferError('sender executable');\n  if (!recipientInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('recipient owner invalid');\n  if (recipientInfo.executable) throw new CreateTransferError('recipient executable');\n  // Check that the amount provided doesn't have greater precision than SOL\n  if ((amount.decimalPlaces() ?? 0) > SOL_DECIMALS) throw new CreateTransferError('amount decimals invalid');\n  // Convert input decimal amount to integer lamports\n  amount = amount.times(LAMPORTS_PER_SOL).integerValue(BigNumber.ROUND_FLOOR);\n  // Check that the sender has enough lamports\n  const lamports = amount.toNumber();\n  if (lamports > senderInfo.lamports) throw new CreateTransferError('insufficient funds');\n  // Create an instruction to transfer native SOL\n  return SystemProgram.transfer({\n    fromPubkey: sender,\n    toPubkey: recipient,\n    lamports\n  });\n}\nasync function createSPLTokenInstruction(recipient, amount, splToken, sender, connection) {\n  // Check that the token provided is an initialized mint\n  const mint = await getMint(connection, splToken);\n  if (!mint.isInitialized) throw new CreateTransferError('mint not initialized');\n  // Check that the amount provided doesn't have greater precision than the mint\n  if ((amount.decimalPlaces() ?? 0) > mint.decimals) throw new CreateTransferError('amount decimals invalid');\n  // Convert input decimal amount to integer tokens according to the mint decimals\n  amount = amount.times(TEN.pow(mint.decimals)).integerValue(BigNumber.ROUND_FLOOR);\n  // Get the sender's ATA and check that the account exists and can send tokens\n  const senderATA = await getAssociatedTokenAddress(splToken, sender);\n  const senderAccount = await getAccount(connection, senderATA);\n  if (!senderAccount.isInitialized) throw new CreateTransferError('sender not initialized');\n  if (senderAccount.isFrozen) throw new CreateTransferError('sender frozen');\n  // Get the recipient's ATA and check that the account exists and can receive tokens\n  const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n  const recipientAccount = await getAccount(connection, recipientATA);\n  if (!recipientAccount.isInitialized) throw new CreateTransferError('recipient not initialized');\n  if (recipientAccount.isFrozen) throw new CreateTransferError('recipient frozen');\n  // Check that the sender has enough tokens\n  const tokens = BigInt(String(amount));\n  if (tokens > senderAccount.amount) throw new CreateTransferError('insufficient funds');\n  // Create an instruction to transfer SPL tokens, asserting the mint and decimals match\n  return createTransferCheckedInstruction(senderATA, splToken, recipientATA, sender, tokens, mint.decimals);\n}","map":{"version":3,"names":["createTransferCheckedInstruction","getAccount","getAssociatedTokenAddress","getMint","LAMPORTS_PER_SOL","SystemProgram","Transaction","TransactionInstruction","BigNumber","MEMO_PROGRAM_ID","SOL_DECIMALS","TEN","CreateTransferError","Error","constructor","name","createTransfer","connection","sender","_ref","recipient","amount","splToken","reference","memo","commitment","arguments","length","undefined","senderInfo","getAccountInfo","recipientInfo","instruction","createSPLTokenInstruction","createSystemInstruction","Array","isArray","pubkey","keys","push","isWritable","isSigner","transaction","feePayer","recentBlockhash","getRecentBlockhash","blockhash","add","programId","data","Buffer","from","owner","equals","executable","decimalPlaces","times","integerValue","ROUND_FLOOR","lamports","toNumber","transfer","fromPubkey","toPubkey","mint","isInitialized","decimals","pow","senderATA","senderAccount","isFrozen","recipientATA","recipientAccount","tokens","BigInt","String"],"sources":["C:\\Users\\Shivam\\OneDrive\\Desktop\\UI-Cashierless-main\\UI-Cashierless-main\\node_modules\\@solana\\pay\\src\\createTransfer.ts"],"sourcesContent":["import { createTransferCheckedInstruction, getAccount, getAssociatedTokenAddress, getMint } from '@solana/spl-token';\nimport type { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { LAMPORTS_PER_SOL, SystemProgram, Transaction, TransactionInstruction } from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID, SOL_DECIMALS, TEN } from './constants.js';\nimport type { Amount, Memo, Recipient, References, SPLToken } from './types.js';\n\n/**\n * Thrown when a Solana Pay transfer transaction can't be created from the fields provided.\n */\nexport class CreateTransferError extends Error {\n    name = 'CreateTransferError';\n}\n\n/**\n * Fields of a Solana Pay transfer request URL.\n */\nexport interface CreateTransferFields {\n    /** `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient). */\n    recipient: Recipient;\n    /** `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount). */\n    amount: Amount;\n    /** `spl-token` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#spl-token). */\n    splToken?: SPLToken;\n    /** `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference). */\n    reference?: References;\n    /** `memo` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#memo). */\n    memo?: Memo;\n}\n\n/**\n * Create a Solana Pay transfer transaction.\n *\n * @param connection - A connection to the cluster.\n * @param sender - Account that will send the transfer.\n * @param fields - Fields of a Solana Pay transfer request URL.\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {CreateTransferError}\n */\nexport async function createTransfer(\n    connection: Connection,\n    sender: PublicKey,\n    { recipient, amount, splToken, reference, memo }: CreateTransferFields,\n    { commitment }: { commitment?: Commitment } = {}\n): Promise<Transaction> {\n    // Check that the sender and recipient accounts exist\n    const senderInfo = await connection.getAccountInfo(sender);\n    if (!senderInfo) throw new CreateTransferError('sender not found');\n\n    const recipientInfo = await connection.getAccountInfo(recipient);\n    if (!recipientInfo) throw new CreateTransferError('recipient not found');\n\n    // A native SOL or SPL token transfer instruction\n    const instruction = splToken\n        ? await createSPLTokenInstruction(recipient, amount, splToken, sender, connection)\n        : await createSystemInstruction(recipient, amount, sender, connection);\n\n    // If reference accounts are provided, add them to the transfer instruction\n    if (reference) {\n        if (!Array.isArray(reference)) {\n            reference = [reference];\n        }\n\n        for (const pubkey of reference) {\n            instruction.keys.push({ pubkey, isWritable: false, isSigner: false });\n        }\n    }\n\n    // Create the transaction\n    const transaction = new Transaction();\n    transaction.feePayer = sender;\n    transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n\n    // If a memo is provided, add it to the transaction before adding the transfer instruction\n    if (memo != null) {\n        transaction.add(\n            new TransactionInstruction({\n                programId: MEMO_PROGRAM_ID,\n                keys: [],\n                data: Buffer.from(memo, 'utf8'),\n            })\n        );\n    }\n\n    // Add the transfer instruction to the transaction\n    transaction.add(instruction);\n\n    return transaction;\n}\n\nasync function createSystemInstruction(\n    recipient: PublicKey,\n    amount: BigNumber,\n    sender: PublicKey,\n    connection: Connection\n): Promise<TransactionInstruction> {\n    // Check that the sender and recipient accounts exist\n    const senderInfo = await connection.getAccountInfo(sender);\n    if (!senderInfo) throw new CreateTransferError('sender not found');\n\n    const recipientInfo = await connection.getAccountInfo(recipient);\n    if (!recipientInfo) throw new CreateTransferError('recipient not found');\n\n    // Check that the sender and recipient are valid native accounts\n    if (!senderInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('sender owner invalid');\n    if (senderInfo.executable) throw new CreateTransferError('sender executable');\n    if (!recipientInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('recipient owner invalid');\n    if (recipientInfo.executable) throw new CreateTransferError('recipient executable');\n\n    // Check that the amount provided doesn't have greater precision than SOL\n    if ((amount.decimalPlaces() ?? 0) > SOL_DECIMALS) throw new CreateTransferError('amount decimals invalid');\n\n    // Convert input decimal amount to integer lamports\n    amount = amount.times(LAMPORTS_PER_SOL).integerValue(BigNumber.ROUND_FLOOR);\n\n    // Check that the sender has enough lamports\n    const lamports = amount.toNumber();\n    if (lamports > senderInfo.lamports) throw new CreateTransferError('insufficient funds');\n\n    // Create an instruction to transfer native SOL\n    return SystemProgram.transfer({\n        fromPubkey: sender,\n        toPubkey: recipient,\n        lamports,\n    });\n}\n\nasync function createSPLTokenInstruction(\n    recipient: PublicKey,\n    amount: BigNumber,\n    splToken: PublicKey,\n    sender: PublicKey,\n    connection: Connection\n): Promise<TransactionInstruction> {\n    // Check that the token provided is an initialized mint\n    const mint = await getMint(connection, splToken);\n    if (!mint.isInitialized) throw new CreateTransferError('mint not initialized');\n\n    // Check that the amount provided doesn't have greater precision than the mint\n    if ((amount.decimalPlaces() ?? 0) > mint.decimals) throw new CreateTransferError('amount decimals invalid');\n\n    // Convert input decimal amount to integer tokens according to the mint decimals\n    amount = amount.times(TEN.pow(mint.decimals)).integerValue(BigNumber.ROUND_FLOOR);\n\n    // Get the sender's ATA and check that the account exists and can send tokens\n    const senderATA = await getAssociatedTokenAddress(splToken, sender);\n    const senderAccount = await getAccount(connection, senderATA);\n    if (!senderAccount.isInitialized) throw new CreateTransferError('sender not initialized');\n    if (senderAccount.isFrozen) throw new CreateTransferError('sender frozen');\n\n    // Get the recipient's ATA and check that the account exists and can receive tokens\n    const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n    const recipientAccount = await getAccount(connection, recipientATA);\n    if (!recipientAccount.isInitialized) throw new CreateTransferError('recipient not initialized');\n    if (recipientAccount.isFrozen) throw new CreateTransferError('recipient frozen');\n\n    // Check that the sender has enough tokens\n    const tokens = BigInt(String(amount));\n    if (tokens > senderAccount.amount) throw new CreateTransferError('insufficient funds');\n\n    // Create an instruction to transfer SPL tokens, asserting the mint and decimals match\n    return createTransferCheckedInstruction(senderATA, splToken, recipientATA, sender, tokens, mint.decimals);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}