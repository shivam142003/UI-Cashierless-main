{"ast":null,"code":"import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidMintError, TokenInvalidOwnerError } from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner) {\n  let allowOwnerOffCurve = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let commitment = arguments.length > 5 ? arguments[5] : undefined;\n  let confirmOptions = arguments.length > 6 ? arguments[6] : undefined;\n  let programId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : TOKEN_PROGRAM_ID;\n  let associatedTokenProgramId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : ASSOCIATED_TOKEN_PROGRAM_ID;\n  const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);\n  // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n  // Sadly we can't do this atomically.\n  let account;\n  try {\n    account = await getAccount(connection, associatedToken, commitment, programId);\n  } catch (error) {\n    // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n    // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n    // TokenInvalidAccountOwnerError in this code path.\n    if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n      // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n      try {\n        const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n      } catch (error) {\n        // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n        // instruction error if the associated account exists already.\n      }\n      // Now this should always succeed\n      account = await getAccount(connection, associatedToken, commitment, programId);\n    } else {\n      throw error;\n    }\n  }\n  if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n  if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n  return account;\n}","map":{"version":3,"names":["sendAndConfirmTransaction","Transaction","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidMintError","TokenInvalidOwnerError","createAssociatedTokenAccountInstruction","getAccount","getAssociatedTokenAddressSync","getOrCreateAssociatedTokenAccount","connection","payer","mint","owner","allowOwnerOffCurve","arguments","length","undefined","commitment","confirmOptions","programId","associatedTokenProgramId","associatedToken","account","error","transaction","add","publicKey","equals"],"sources":["C:\\Users\\Shivam\\OneDrive\\Desktop\\UI-Cashierless-finalmain\\UI-Cashierless-main\\node_modules\\@solana\\spl-token\\src\\actions\\getOrCreateAssociatedTokenAccount.ts"],"sourcesContent":["import type { Commitment, ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport type { Account } from '../state/account.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const associatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId\n                    )\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n"],"mappings":"AACA,SAASA,yBAAyB,EAAEC,WAAW,QAAQ,iBAAiB;AACxE,SAASC,2BAA2B,EAAEC,gBAAgB,QAAQ,iBAAiB;AAC/E,SACIC,yBAAyB,EACzBC,6BAA6B,EAC7BC,qBAAqB,EACrBC,sBAAsB,QACnB,cAAc;AACrB,SAASC,uCAAuC,QAAQ,2CAA2C;AAEnG,SAASC,UAAU,QAAQ,qBAAqB;AAChD,SAASC,6BAA6B,QAAQ,kBAAkB;AAEhE;;;;;;;;;;;;;;;AAeA,OAAO,eAAeC,iCAAiCA,CACnDC,UAAsB,EACtBC,KAAa,EACbC,IAAe,EACfC,KAAgB,EAKsC;EAAA,IAJtDC,kBAAkB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAAA,IAC1BG,UAAuB,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IACvBE,cAA+B,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAC/BG,SAAS,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGd,gBAAgB;EAAA,IAC5BoB,wBAAwB,GAAAN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGf,2BAA2B;EAEtD,MAAMsB,eAAe,GAAGd,6BAA6B,CACjDI,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBM,SAAS,EACTC,wBAAwB,CAC3B;EAED;EACA;EACA,IAAIE,OAAgB;EACpB,IAAI;IACAA,OAAO,GAAG,MAAMhB,UAAU,CAACG,UAAU,EAAEY,eAAe,EAAEJ,UAAU,EAAEE,SAAS,CAAC;GACjF,CAAC,OAAOI,KAAc,EAAE;IACrB;IACA;IACA;IACA,IAAIA,KAAK,YAAYtB,yBAAyB,IAAIsB,KAAK,YAAYrB,6BAA6B,EAAE;MAC9F;MACA,IAAI;QACA,MAAMsB,WAAW,GAAG,IAAI1B,WAAW,EAAE,CAAC2B,GAAG,CACrCpB,uCAAuC,CACnCK,KAAK,CAACgB,SAAS,EACfL,eAAe,EACfT,KAAK,EACLD,IAAI,EACJQ,SAAS,EACTC,wBAAwB,CAC3B,CACJ;QAED,MAAMvB,yBAAyB,CAACY,UAAU,EAAEe,WAAW,EAAE,CAACd,KAAK,CAAC,EAAEQ,cAAc,CAAC;OACpF,CAAC,OAAOK,KAAc,EAAE;QACrB;QACA;MAAA;MAGJ;MACAD,OAAO,GAAG,MAAMhB,UAAU,CAACG,UAAU,EAAEY,eAAe,EAAEJ,UAAU,EAAEE,SAAS,CAAC;KACjF,MAAM;MACH,MAAMI,KAAK;;;EAInB,IAAI,CAACD,OAAO,CAACX,IAAI,CAACgB,MAAM,CAAChB,IAAI,CAAC,EAAE,MAAM,IAAIR,qBAAqB,EAAE;EACjE,IAAI,CAACmB,OAAO,CAACV,KAAK,CAACe,MAAM,CAACf,KAAK,CAAC,EAAE,MAAM,IAAIR,sBAAsB,EAAE;EAEpE,OAAOkB,OAAO;AAClB"},"metadata":{},"sourceType":"module","externalDependencies":[]}