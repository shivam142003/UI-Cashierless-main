{"ast":null,"code":"import { decodeInstruction, getAssociatedTokenAddress, isTransferCheckedInstruction, isTransferInstruction } from '@solana/spl-token';\nimport { LAMPORTS_PER_SOL, SystemInstruction, Transaction } from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID } from './constants.js';\n/**\n * Thrown when a transaction doesn't contain a valid Solana Pay transfer.\n */\nexport class ValidateTransferError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'ValidateTransferError';\n  }\n}\n/**\n * Check that a given transaction contains a valid Solana Pay transfer.\n *\n * @param connection - A connection to the cluster.\n * @param signature - The signature of the transaction to validate.\n * @param fields - Fields of a Solana Pay transfer request to validate.\n * @param options - Options for `getTransaction`.\n *\n * @throws {ValidateTransferError}\n */\nexport async function validateTransfer(connection, signature, _ref, options) {\n  let {\n    recipient,\n    amount,\n    splToken,\n    reference,\n    memo\n  } = _ref;\n  const response = await connection.getTransaction(signature, options);\n  if (!response) throw new ValidateTransferError('not found');\n  const {\n    message,\n    signatures\n  } = response.transaction;\n  const meta = response.meta;\n  if (!meta) throw new ValidateTransferError('missing meta');\n  if (meta.err) throw meta.err;\n  if (reference && !Array.isArray(reference)) {\n    reference = [reference];\n  }\n  // Deserialize the transaction and make a copy of the instructions we're going to validate.\n  const transaction = Transaction.populate(message, signatures);\n  const instructions = transaction.instructions.slice();\n  // Transfer instruction must be the last instruction\n  const instruction = instructions.pop();\n  if (!instruction) throw new ValidateTransferError('missing transfer instruction');\n  const [preAmount, postAmount] = splToken ? await validateSPLTokenTransfer(instruction, message, meta, recipient, splToken, reference) : await validateSystemTransfer(instruction, message, meta, recipient, reference);\n  if (postAmount.minus(preAmount).lt(amount)) throw new ValidateTransferError('amount not transferred');\n  if (memo !== undefined) {\n    // Memo instruction must be the second to last instruction\n    const instruction = instructions.pop();\n    if (!instruction) throw new ValidateTransferError('missing memo instruction');\n    validateMemo(instruction, memo);\n  }\n  return response;\n}\nfunction validateMemo(instruction, memo) {\n  // Check that the instruction is a memo instruction with no keys and the expected memo data.\n  if (!instruction.programId.equals(MEMO_PROGRAM_ID)) throw new ValidateTransferError('invalid memo program');\n  if (instruction.keys.length) throw new ValidateTransferError('invalid memo keys');\n  if (!instruction.data.equals(Buffer.from(memo, 'utf8'))) throw new ValidateTransferError('invalid memo');\n}\nasync function validateSystemTransfer(instruction, message, meta, recipient, references) {\n  const accountIndex = message.accountKeys.findIndex(pubkey => pubkey.equals(recipient));\n  if (accountIndex === -1) throw new ValidateTransferError('recipient not found');\n  if (references) {\n    // Check that the instruction is a system transfer instruction.\n    SystemInstruction.decodeTransfer(instruction);\n    // Check that the expected reference keys exactly match the extra keys provided to the instruction.\n    const [_from, _to, ...extraKeys] = instruction.keys;\n    const length = extraKeys.length;\n    if (length !== references.length) throw new ValidateTransferError('invalid references');\n    for (let i = 0; i < length; i++) {\n      if (!extraKeys[i].pubkey.equals(references[i])) throw new ValidateTransferError(`invalid reference ${i}`);\n    }\n  }\n  return [new BigNumber(meta.preBalances[accountIndex] || 0).div(LAMPORTS_PER_SOL), new BigNumber(meta.postBalances[accountIndex] || 0).div(LAMPORTS_PER_SOL)];\n}\nasync function validateSPLTokenTransfer(instruction, message, meta, recipient, splToken, references) {\n  const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n  const accountIndex = message.accountKeys.findIndex(pubkey => pubkey.equals(recipientATA));\n  if (accountIndex === -1) throw new ValidateTransferError('recipient not found');\n  if (references) {\n    // Check that the first instruction is an SPL token transfer instruction.\n    const decodedInstruction = decodeInstruction(instruction);\n    if (!isTransferCheckedInstruction(decodedInstruction) && !isTransferInstruction(decodedInstruction)) throw new ValidateTransferError('invalid transfer');\n    // Check that the expected reference keys exactly match the extra keys provided to the instruction.\n    const extraKeys = decodedInstruction.keys.multiSigners;\n    const length = extraKeys.length;\n    if (length !== references.length) throw new ValidateTransferError('invalid references');\n    for (let i = 0; i < length; i++) {\n      if (!extraKeys[i].pubkey.equals(references[i])) throw new ValidateTransferError(`invalid reference ${i}`);\n    }\n  }\n  const preBalance = meta.preTokenBalances?.find(x => x.accountIndex === accountIndex);\n  const postBalance = meta.postTokenBalances?.find(x => x.accountIndex === accountIndex);\n  return [new BigNumber(preBalance?.uiTokenAmount.uiAmountString || 0), new BigNumber(postBalance?.uiTokenAmount.uiAmountString || 0)];\n}","map":{"version":3,"names":["decodeInstruction","getAssociatedTokenAddress","isTransferCheckedInstruction","isTransferInstruction","LAMPORTS_PER_SOL","SystemInstruction","Transaction","BigNumber","MEMO_PROGRAM_ID","ValidateTransferError","Error","constructor","name","validateTransfer","connection","signature","_ref","options","recipient","amount","splToken","reference","memo","response","getTransaction","message","signatures","transaction","meta","err","Array","isArray","populate","instructions","slice","instruction","pop","preAmount","postAmount","validateSPLTokenTransfer","validateSystemTransfer","minus","lt","undefined","validateMemo","programId","equals","keys","length","data","Buffer","from","references","accountIndex","accountKeys","findIndex","pubkey","decodeTransfer","_from","_to","extraKeys","i","preBalances","div","postBalances","recipientATA","decodedInstruction","multiSigners","preBalance","preTokenBalances","find","x","postBalance","postTokenBalances","uiTokenAmount","uiAmountString"],"sources":["C:\\Users\\Shivam\\OneDrive\\Desktop\\UI-Cashierless-finalmain\\UI-Cashierless-main\\node_modules\\@solana\\pay\\src\\validateTransfer.ts"],"sourcesContent":["import {\n    decodeInstruction,\n    getAssociatedTokenAddress,\n    isTransferCheckedInstruction,\n    isTransferInstruction,\n} from '@solana/spl-token';\nimport type {\n    ConfirmedTransactionMeta,\n    Connection,\n    Finality,\n    Message,\n    TransactionInstruction,\n    TransactionResponse,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { LAMPORTS_PER_SOL, SystemInstruction, Transaction } from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID } from './constants.js';\nimport type { Amount, Memo, Recipient, Reference, References, SPLToken } from './types.js';\n\n/**\n * Thrown when a transaction doesn't contain a valid Solana Pay transfer.\n */\nexport class ValidateTransferError extends Error {\n    name = 'ValidateTransferError';\n}\n\n/**\n * Fields of a Solana Pay transfer request to validate.\n */\nexport interface ValidateTransferFields {\n    /** `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient). */\n    recipient: Recipient;\n    /** `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount). */\n    amount: Amount;\n    /** `spl-token` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#spl-token). */\n    splToken?: SPLToken;\n    /** `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference). */\n    reference?: References;\n    /** `memo` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#memo). */\n    memo?: Memo;\n}\n\n/**\n * Check that a given transaction contains a valid Solana Pay transfer.\n *\n * @param connection - A connection to the cluster.\n * @param signature - The signature of the transaction to validate.\n * @param fields - Fields of a Solana Pay transfer request to validate.\n * @param options - Options for `getTransaction`.\n *\n * @throws {ValidateTransferError}\n */\nexport async function validateTransfer(\n    connection: Connection,\n    signature: TransactionSignature,\n    { recipient, amount, splToken, reference, memo }: ValidateTransferFields,\n    options?: { commitment?: Finality }\n): Promise<TransactionResponse> {\n    const response = await connection.getTransaction(signature, options);\n    if (!response) throw new ValidateTransferError('not found');\n\n    const { message, signatures } = response.transaction;\n    const meta = response.meta;\n    if (!meta) throw new ValidateTransferError('missing meta');\n    if (meta.err) throw meta.err;\n\n    if (reference && !Array.isArray(reference)) {\n        reference = [reference];\n    }\n\n    // Deserialize the transaction and make a copy of the instructions we're going to validate.\n    const transaction = Transaction.populate(message, signatures);\n    const instructions = transaction.instructions.slice();\n\n    // Transfer instruction must be the last instruction\n    const instruction = instructions.pop();\n    if (!instruction) throw new ValidateTransferError('missing transfer instruction');\n    const [preAmount, postAmount] = splToken\n        ? await validateSPLTokenTransfer(instruction, message, meta, recipient, splToken, reference)\n        : await validateSystemTransfer(instruction, message, meta, recipient, reference);\n    if (postAmount.minus(preAmount).lt(amount)) throw new ValidateTransferError('amount not transferred');\n\n    if (memo !== undefined) {\n        // Memo instruction must be the second to last instruction\n        const instruction = instructions.pop();\n        if (!instruction) throw new ValidateTransferError('missing memo instruction');\n        validateMemo(instruction, memo);\n    }\n\n    return response;\n}\n\nfunction validateMemo(instruction: TransactionInstruction, memo: string): void {\n    // Check that the instruction is a memo instruction with no keys and the expected memo data.\n    if (!instruction.programId.equals(MEMO_PROGRAM_ID)) throw new ValidateTransferError('invalid memo program');\n    if (instruction.keys.length) throw new ValidateTransferError('invalid memo keys');\n    if (!instruction.data.equals(Buffer.from(memo, 'utf8'))) throw new ValidateTransferError('invalid memo');\n}\n\nasync function validateSystemTransfer(\n    instruction: TransactionInstruction,\n    message: Message,\n    meta: ConfirmedTransactionMeta,\n    recipient: Recipient,\n    references?: Reference[]\n): Promise<[BigNumber, BigNumber]> {\n    const accountIndex = message.accountKeys.findIndex((pubkey) => pubkey.equals(recipient));\n    if (accountIndex === -1) throw new ValidateTransferError('recipient not found');\n\n    if (references) {\n        // Check that the instruction is a system transfer instruction.\n        SystemInstruction.decodeTransfer(instruction);\n\n        // Check that the expected reference keys exactly match the extra keys provided to the instruction.\n        const [_from, _to, ...extraKeys] = instruction.keys;\n        const length = extraKeys.length;\n        if (length !== references.length) throw new ValidateTransferError('invalid references');\n\n        for (let i = 0; i < length; i++) {\n            if (!extraKeys[i].pubkey.equals(references[i])) throw new ValidateTransferError(`invalid reference ${i}`);\n        }\n    }\n\n    return [\n        new BigNumber(meta.preBalances[accountIndex] || 0).div(LAMPORTS_PER_SOL),\n        new BigNumber(meta.postBalances[accountIndex] || 0).div(LAMPORTS_PER_SOL),\n    ];\n}\n\nasync function validateSPLTokenTransfer(\n    instruction: TransactionInstruction,\n    message: Message,\n    meta: ConfirmedTransactionMeta,\n    recipient: Recipient,\n    splToken: SPLToken,\n    references?: Reference[]\n): Promise<[BigNumber, BigNumber]> {\n    const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n    const accountIndex = message.accountKeys.findIndex((pubkey) => pubkey.equals(recipientATA));\n    if (accountIndex === -1) throw new ValidateTransferError('recipient not found');\n\n    if (references) {\n        // Check that the first instruction is an SPL token transfer instruction.\n        const decodedInstruction = decodeInstruction(instruction);\n        if (!isTransferCheckedInstruction(decodedInstruction) && !isTransferInstruction(decodedInstruction))\n            throw new ValidateTransferError('invalid transfer');\n\n        // Check that the expected reference keys exactly match the extra keys provided to the instruction.\n        const extraKeys = decodedInstruction.keys.multiSigners;\n        const length = extraKeys.length;\n        if (length !== references.length) throw new ValidateTransferError('invalid references');\n\n        for (let i = 0; i < length; i++) {\n            if (!extraKeys[i].pubkey.equals(references[i])) throw new ValidateTransferError(`invalid reference ${i}`);\n        }\n    }\n\n    const preBalance = meta.preTokenBalances?.find((x) => x.accountIndex === accountIndex);\n    const postBalance = meta.postTokenBalances?.find((x) => x.accountIndex === accountIndex);\n\n    return [\n        new BigNumber(preBalance?.uiTokenAmount.uiAmountString || 0),\n        new BigNumber(postBalance?.uiTokenAmount.uiAmountString || 0),\n    ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}