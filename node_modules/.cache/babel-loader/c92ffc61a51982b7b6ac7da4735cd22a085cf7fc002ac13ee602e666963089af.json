{"ast":null,"code":"import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nexport var TransferFeeInstruction;\n(function (TransferFeeInstruction) {\n  TransferFeeInstruction[TransferFeeInstruction[\"InitializeTransferFeeConfig\"] = 0] = \"InitializeTransferFeeConfig\";\n  TransferFeeInstruction[TransferFeeInstruction[\"TransferCheckedWithFee\"] = 1] = \"TransferCheckedWithFee\";\n  TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromMint\"] = 2] = \"WithdrawWithheldTokensFromMint\";\n  TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromAccounts\"] = 3] = \"WithdrawWithheldTokensFromAccounts\";\n  TransferFeeInstruction[TransferFeeInstruction[\"HarvestWithheldTokensToMint\"] = 4] = \"HarvestWithheldTokensToMint\";\n  TransferFeeInstruction[TransferFeeInstruction[\"SetTransferFee\"] = 5] = \"SetTransferFee\";\n})(TransferFeeInstruction || (TransferFeeInstruction = {}));\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u8('transferFeeConfigAuthorityOption'), publicKey('transferFeeConfigAuthority'), u8('withdrawWithheldAuthorityOption'), publicKey('withdrawWithheldAuthority'), u16('transferFeeBasisPoints'), u64('maximumFee')]);\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee) {\n  let programId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : TOKEN_2022_PROGRAM_ID;\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  const data = Buffer.alloc(initializeTransferFeeConfigInstructionData.span);\n  initializeTransferFeeConfigInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n    transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,\n    transferFeeConfigAuthority: transferFeeConfigAuthority || new PublicKey(0),\n    withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,\n    withdrawWithheldAuthority: withdrawWithheldAuthority || new PublicKey(0),\n    transferFeeBasisPoints: transferFeeBasisPoints,\n    maximumFee: maximumFee\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== initializeTransferFeeConfigInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint\n    },\n    data\n  } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint\n    },\n    data\n  };\n}\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked(_ref) {\n  let {\n    programId,\n    keys: [mint],\n    data\n  } = _ref;\n  const {\n    instruction,\n    transferFeeInstruction,\n    transferFeeConfigAuthorityOption,\n    transferFeeConfigAuthority,\n    withdrawWithheldAuthorityOption,\n    withdrawWithheldAuthority,\n    transferFeeBasisPoints,\n    maximumFee\n  } = initializeTransferFeeConfigInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,\n      withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,\n      transferFeeBasisPoints,\n      maximumFee\n    }\n  };\n}\nexport const transferCheckedWithFeeInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u64('amount'), u8('decimals'), u64('fee')]);\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee) {\n  let multiSigners = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];\n  let programId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : TOKEN_2022_PROGRAM_ID;\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n  transferCheckedWithFeeInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n    amount,\n    decimals,\n    fee\n  }, data);\n  const keys = addSigners([{\n    pubkey: source,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: mint,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }], authority, multiSigners);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedWithFeeInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== transferCheckedWithFeeInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data\n  } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null\n    },\n    data\n  };\n}\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked(_ref2) {\n  let {\n    programId,\n    keys: [source, mint, destination, authority, ...signers],\n    data\n  } = _ref2;\n  const {\n    instruction,\n    transferFeeInstruction,\n    amount,\n    decimals,\n    fee\n  } = transferCheckedWithFeeInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      amount,\n      decimals,\n      fee\n    }\n  };\n}\nexport const withdrawWithheldTokensFromMintInstructionData = struct([u8('instruction'), u8('transferFeeInstruction')]);\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority) {\n  let signers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let programId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TOKEN_2022_PROGRAM_ID;\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n  withdrawWithheldTokensFromMintInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint\n  }, data);\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }], authority, signers);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data\n  } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null\n    },\n    data\n  };\n}\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked(_ref3) {\n  let {\n    programId,\n    keys: [mint, destination, authority, ...signers],\n    data\n  } = _ref3;\n  const {\n    instruction,\n    transferFeeInstruction\n  } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data: {\n      instruction,\n      transferFeeInstruction\n    }\n  };\n}\nexport const withdrawWithheldTokensFromAccountsInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u8('numTokenAccounts')]);\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources) {\n  let programId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : TOKEN_2022_PROGRAM_ID;\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n  withdrawWithheldTokensFromAccountsInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n    numTokenAccounts: sources.length\n  }, data);\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }], authority, signers);\n  for (const source of sources) {\n    keys.push({\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    });\n  }\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers,\n      sources\n    },\n    data\n  } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null,\n      sources: sources ? sources : null\n    },\n    data\n  };\n}\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(_ref4) {\n  let {\n    programId,\n    keys,\n    data\n  } = _ref4;\n  const {\n    instruction,\n    transferFeeInstruction,\n    numTokenAccounts\n  } = withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n  const [mint, destination, authority, signers, sources] = [keys[0], keys[1], keys[2], keys.slice(3, 3 + numTokenAccounts), keys.slice(-1 * numTokenAccounts)];\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers,\n      sources\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      numTokenAccounts\n    }\n  };\n}\nexport const harvestWithheldTokensToMintInstructionData = struct([u8('instruction'), u8('transferFeeInstruction')]);\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createHarvestWithheldTokensToMintInstruction(mint, sources) {\n  let programId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TOKEN_2022_PROGRAM_ID;\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n  harvestWithheldTokensToMintInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint\n  }, data);\n  const keys = [];\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  });\n  for (const source of sources) {\n    keys.push({\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    });\n  }\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      sources\n    },\n    data\n  } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      sources\n    },\n    data\n  };\n}\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked(_ref5) {\n  let {\n    programId,\n    keys: [mint, ...sources],\n    data\n  } = _ref5;\n  const {\n    instruction,\n    transferFeeInstruction\n  } = harvestWithheldTokensToMintInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint,\n      sources\n    },\n    data: {\n      instruction,\n      transferFeeInstruction\n    }\n  };\n}","map":{"version":3,"names":["struct","u16","u8","publicKey","u64","PublicKey","TransactionInstruction","programSupportsExtensions","TOKEN_2022_PROGRAM_ID","TokenInvalidInstructionDataError","TokenInvalidInstructionKeysError","TokenInvalidInstructionProgramError","TokenInvalidInstructionTypeError","TokenUnsupportedInstructionError","addSigners","TokenInstruction","TransferFeeInstruction","initializeTransferFeeConfigInstructionData","createInitializeTransferFeeConfigInstruction","mint","transferFeeConfigAuthority","withdrawWithheldAuthority","transferFeeBasisPoints","maximumFee","programId","arguments","length","undefined","keys","pubkey","isSigner","isWritable","data","Buffer","alloc","span","encode","instruction","TransferFeeExtension","transferFeeInstruction","InitializeTransferFeeConfig","transferFeeConfigAuthorityOption","withdrawWithheldAuthorityOption","decodeInitializeTransferFeeConfigInstruction","equals","decodeInitializeTransferFeeConfigInstructionUnchecked","_ref","decode","transferCheckedWithFeeInstructionData","createTransferCheckedWithFeeInstruction","source","destination","authority","amount","decimals","fee","multiSigners","TransferCheckedWithFee","decodeTransferCheckedWithFeeInstruction","signers","decodeTransferCheckedWithFeeInstructionUnchecked","_ref2","withdrawWithheldTokensFromMintInstructionData","createWithdrawWithheldTokensFromMintInstruction","WithdrawWithheldTokensFromMint","decodeWithdrawWithheldTokensFromMintInstruction","decodeWithdrawWithheldTokensFromMintInstructionUnchecked","_ref3","withdrawWithheldTokensFromAccountsInstructionData","createWithdrawWithheldTokensFromAccountsInstruction","sources","WithdrawWithheldTokensFromAccounts","numTokenAccounts","push","decodeWithdrawWithheldTokensFromAccountsInstruction","decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked","_ref4","slice","harvestWithheldTokensToMintInstructionData","createHarvestWithheldTokensToMintInstruction","HarvestWithheldTokensToMint","decodeHarvestWithheldTokensToMintInstruction","decodeHarvestWithheldTokensToMintInstructionUnchecked","_ref5"],"sources":["C:\\Users\\Shivam\\OneDrive\\Desktop\\UI-Cashierless-finalmain\\UI-Cashierless-main\\node_modules\\@solana\\spl-token\\src\\extensions\\transferFee\\instructions.ts"],"sourcesContent":["import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum TransferFeeInstruction {\n    InitializeTransferFeeConfig = 0,\n    TransferCheckedWithFee = 1,\n    WithdrawWithheldTokensFromMint = 2,\n    WithdrawWithheldTokensFromAccounts = 3,\n    HarvestWithheldTokensToMint = 4,\n    SetTransferFee = 5,\n}\n\n// InitializeTransferFeeConfig\n\n/** TODO: docs */\nexport interface InitializeTransferFeeConfigInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n    transferFeeConfigAuthorityOption: 1 | 0;\n    transferFeeConfigAuthority: PublicKey;\n    withdrawWithheldAuthorityOption: 1 | 0;\n    withdrawWithheldAuthority: PublicKey;\n    transferFeeBasisPoints: number;\n    maximumFee: bigint;\n}\n\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct<InitializeTransferFeeConfigInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u8('transferFeeConfigAuthorityOption'),\n    publicKey('transferFeeConfigAuthority'),\n    u8('withdrawWithheldAuthorityOption'),\n    publicKey('withdrawWithheldAuthority'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferFeeConfigInstruction(\n    mint: PublicKey,\n    transferFeeConfigAuthority: PublicKey | null,\n    withdrawWithheldAuthority: PublicKey | null,\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeTransferFeeConfigInstructionData.span);\n    initializeTransferFeeConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n            transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,\n            transferFeeConfigAuthority: transferFeeConfigAuthority || new PublicKey(0),\n            withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,\n            withdrawWithheldAuthority: withdrawWithheldAuthority || new PublicKey(0),\n            transferFeeBasisPoints: transferFeeBasisPoints,\n            maximumFee: maximumFee,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeTransferFeeConfigInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedInitializeTransferFeeConfigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeTransferFeeConfigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    const {\n        instruction,\n        transferFeeInstruction,\n        transferFeeConfigAuthorityOption,\n        transferFeeConfigAuthority,\n        withdrawWithheldAuthorityOption,\n        withdrawWithheldAuthority,\n        transferFeeBasisPoints,\n        maximumFee,\n    } = initializeTransferFeeConfigInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,\n            withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\n\n// TransferCheckedWithFee\nexport interface TransferCheckedWithFeeInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n    amount: bigint;\n    decimals: number;\n    fee: bigint;\n}\n\nexport const transferCheckedWithFeeInstructionData = struct<TransferCheckedWithFeeInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u64('amount'),\n    u8('decimals'),\n    u64('fee'),\n]);\n\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedWithFeeInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n    transferCheckedWithFeeInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n            amount,\n            decimals,\n            fee,\n        },\n        data\n    );\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferCheckedWithFee instruction */\nexport interface DecodedTransferCheckedWithFeeInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedWithFeeInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedTransferCheckedWithFeeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, authority, signers },\n        data,\n    } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferCheckedWithFees instruction */\nexport interface DecodedTransferCheckedWithFeeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedWithFeeInstructionUnchecked {\n    const { instruction, transferFeeInstruction, amount, decimals, fee } =\n        transferCheckedWithFeeInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            amount,\n            decimals,\n            fee,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromMint\nexport interface WithdrawWithheldTokensFromMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n}\n\nexport const withdrawWithheldTokensFromMintInstructionData = struct<WithdrawWithheldTokensFromMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n    withdrawWithheldTokensFromMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint,\n        },\n        data\n    );\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        signers\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedWithdrawWithheldTokensFromMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers },\n        data,\n    } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromAccounts\nexport interface WithdrawWithheldTokensFromAccountsInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n    numTokenAccounts: number;\n}\n\nexport const withdrawWithheldTokensFromAccountsInstructionData =\n    struct<WithdrawWithheldTokensFromAccountsInstructionData>([\n        u8('instruction'),\n        u8('transferFeeInstruction'),\n        u8('numTokenAccounts'),\n    ]);\n\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[],\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n    withdrawWithheldTokensFromAccountsInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n            numTokenAccounts: sources.length,\n        },\n        data\n    );\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        signers\n    );\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers, sources },\n        data,\n    } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n            sources: sources ? sources : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({\n    programId,\n    keys,\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    const { instruction, transferFeeInstruction, numTokenAccounts } =\n        withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n    const [mint, destination, authority, signers, sources] = [\n        keys[0],\n        keys[1],\n        keys[2],\n        keys.slice(3, 3 + numTokenAccounts),\n        keys.slice(-1 * numTokenAccounts),\n    ];\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            numTokenAccounts,\n        },\n    };\n}\n\n// HarvestWithheldTokensToMint\n\nexport interface HarvestWithheldTokensToMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n}\n\nexport const harvestWithheldTokensToMintInstructionData = struct<HarvestWithheldTokensToMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createHarvestWithheldTokensToMintInstruction(\n    mint: PublicKey,\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n    harvestWithheldTokensToMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint,\n        },\n        data\n    );\n    const keys: AccountMeta[] = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true });\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedHarvestWithheldTokensToMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, sources },\n        data,\n    } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({\n    programId,\n    keys: [mint, ...sources],\n    data,\n}: TransactionInstruction): DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}